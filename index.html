<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="编程语言C++，主要混迹于ACWing...">
<meta property="og:type" content="website">
<meta property="og:title" content="Hugo的个人小站">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hugo的个人小站">
<meta property="og:description" content="编程语言C++，主要混迹于ACWing...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Winter&#x2F;Hugo">
<meta property="article:tag" content="C++, CSP, NOIP, NOI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hugo的个人小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hugo的个人小站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">六年级蒟蒻，OIer@Beijing</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/01/dp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Winter/Hugo">
      <meta itemprop="description" content="编程语言C++，主要混迹于ACWing...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hugo的个人小站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/01/dp/" class="post-title-link" itemprop="url">dp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-01 18:50:21 / 修改时间：18:55:39" itemprop="dateCreated datePublished" datetime="2022-02-01T18:50:21+08:00">2022-02-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我把该说的都在前面说了把<br>我这里的主旨是让大家系统的了解DP问题，将会把基础课/提高课DP题目全部讲一遍。这篇分享可能非常长！！！实在不行我就拆开。<br>长度甚至有可能超过<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/69403/">这个</a>！！！！提高课是在我另一个号上报的，如果你看不了提高课的题目也不要紧，每道题我都有简单的题目概括。</p>
<h1 id="DP"><a href="#DP" class="headerlink" title="$$DP$$"></a>$$DP$$</h1><h2 id="第一章-基本概念"><a href="#第一章-基本概念" class="headerlink" title="$$第一章 \ \ 基本概念$$"></a>$$第一章 \ \ 基本概念$$</h2><p>$$这一章节的内容非(hao)常(wu)有(yong)用(chu)，能让你更好的理解DP的基本概念。$$</p>
<h3 id="1-DP的定义"><a href="#1-DP的定义" class="headerlink" title="1.DP的定义"></a>1.DP的定义</h3><blockquote>
<p>$ \ \ \ \ \ \ $ 动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。</p>
</blockquote>
<h3 id="2-DP的概念引入"><a href="#2-DP的概念引入" class="headerlink" title="2.DP的概念引入"></a>2.DP的概念引入</h3><blockquote>
<p>$ \ \ \ \ \ \ $ 在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。</p>
</blockquote>
<h3 id="3-DP的基本思想"><a href="#3-DP的基本思想" class="headerlink" title="3.DP的基本思想"></a>3.DP的基本思想</h3><blockquote>
<p>$ \ \ \ \ \ \ $ 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式 。</p>
</blockquote>
<h3 id="4-DP的基本概念"><a href="#4-DP的基本概念" class="headerlink" title="4.DP的基本概念"></a>4.DP的基本概念</h3><h4 id="（1）多阶段决策问题"><a href="#（1）多阶段决策问题" class="headerlink" title="（1）多阶段决策问题"></a>（1）多阶段决策问题</h4><blockquote>
<p>$ \ \ \ \ \ \ $ 如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题。<br>$ \ \ \ \ \ \ $ 各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</p>
</blockquote>
<h4 id="（2）动态规划问题中的术语"><a href="#（2）动态规划问题中的术语" class="headerlink" title="（2）动态规划问题中的术语"></a>（2）动态规划问题中的术语</h4><blockquote>
<p>$ \ \ \ \ \ \ $ <strong>阶段</strong>：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。<br>$ \ \ \ \ \ \ $ <strong>状态</strong>：状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点。<br>$ \ \ \ \ \ \ $ <strong>无后效性</strong>：我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。<br>$ \ \ \ \ \ \ $ <strong>决策</strong>：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史 。另外，决策变量的范围称为允许决策集合。<br>$ \ \ \ \ \ \ $ <strong>策略</strong>：由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合，允许策略集合中达到最优效果的策略称为最优策略。<br>$ \ \ \ \ \ \ $ <strong>状态转移方程</strong>：两个状态转移的递推关系式，动态规划中本阶段的状态固定是上一阶段状态和上一阶段决策的结果。<br>$ \ \ \ \ \ \ $ <strong>最优化原理</strong>：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”，最优性原理实际上是要求问题的最优策略的子策略也是最优。</p>
</blockquote>
<h3 id="5-基本结构"><a href="#5-基本结构" class="headerlink" title="5.基本结构"></a>5.基本结构</h3><blockquote>
<p>$ \ \ \ \ \ \ $ 多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法 。</p>
</blockquote>
<h3 id="6-适用条件"><a href="#6-适用条件" class="headerlink" title="6.适用条件"></a>6.适用条件</h3><ul>
<li>最优化原理（最优子结构性质）</li>
</ul>
<blockquote>
<p>$ \ \ \ \ \ \ $ 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</p>
</blockquote>
<ul>
<li>无后效性</li>
</ul>
<blockquote>
<p>$ \ \ \ \ \ \ $ 将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p>
</blockquote>
<ul>
<li>子问题的重叠性</li>
</ul>
<blockquote>
<p>$ \ \ \ \ \ \ $ 动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间。</p>
</blockquote>
<h3 id="7-分类"><a href="#7-分类" class="headerlink" title="7.分类"></a>7.分类</h3><p>这里在百度上的解释过于深奥无用，我这里说几个DP的知识点分类。</p>
<ol>
<li>背包DP</li>
<li>线性DP</li>
<li>区间DP</li>
<li>状态压缩DP</li>
<li>树形DP</li>
<li>记忆化DP</li>
<li>计数DP</li>
<li>数位统计DP</li>
<li>状态机DP</li>
<li>优化DP<ol>
<li>单调队列优化DP</li>
<li>斜率优化DP</li>
<li>四边形不等式优化DP</li>
<li>…</li>
</ol>
</li>
<li>模型<ol>
<li>数字三角形模型</li>
<li>最长上升子序列模型</li>
<li>…</li>
</ol>
</li>
<li>基环树DP</li>
<li>插头DP</li>
<li>…</li>
</ol>
<h3 id="8-局限性"><a href="#8-局限性" class="headerlink" title="8.局限性"></a>8.局限性</h3><blockquote>
<p>$ \ \ \ \ \ \ $ 动态规划对于解决多阶段决策问题的效果是明显的，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是“维数障碍”。</p>
</blockquote>
<p>$$理解了这些术语，可我们怎么解决DP问题呢？跟我一起走进下一章！$$</p>
<h2 id="第二章-解决方案"><a href="#第二章-解决方案" class="headerlink" title="$$第二章 \ \ 解决方案$$"></a>$$第二章 \ \ 解决方案$$</h2><p>$$上一章，我们学习了DP是什么东西，现在，是时候学习怎么解决DP问题了！$$</p>
<p>这就引出了我们的——</p>
<h1 id="闫氏DP分析法"><a href="#闫氏DP分析法" class="headerlink" title="$$ 闫氏DP分析法 $$"></a>$$ 闫氏DP分析法 $$</h1><p>话不多说，现在我们就开始认识闫氏DP分析法。先从一张图开始。<br><img src="https://cdn.acwing.com/media/article/image/2020/03/25/13039_154f0d0e6e-%E5%9B%BE%E7%89%874.jpg" alt="闫氏DP分析法"><br>现在我们就用 $\color{red}{“树”}$ 来理解一下这幅图。</p>
<ul>
<li>DP<ul>
<li>状态表示<ul>
<li>集合<ul>
<li>所有满足xx的xx集合——数组 $f[i][j]$ 的含义</li>
<li>确定所属模型——这个在写的时候不用写出来，你只要看懂这是什么类型的DP就行了，前面有介绍。</li>
</ul>
</li>
<li>属性——分为三大类：最大最小，个数，是否。表示最优策略的判断方法，也就是所以决策的判断方法。</li>
</ul>
</li>
<li>状态计算<ul>
<li>划分为多少子集——有哪些决策。</li>
<li>划分准则——不重复，不遗漏（求最大最小是可以重复）。</li>
<li>划分技巧——可以从最后一个与其他决策不同点入手。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>解决问题有三部曲：</p>
<ol>
<li>考虑数组的含义（状态表示——集合）</li>
<li>确定属性（状态表示——属性）</li>
<li>由数组的含义与属性推出状态转移方程（状态计算——集合划分） </li>
</ol>
<p>时间复杂度：<br>$$学会了方法，可是怎么应用呢？跟我一起走进下一章！$$</p>
<h2 id="第三章-解决问题"><a href="#第三章-解决问题" class="headerlink" title="$$第三章 \ \ 解决问题$$"></a>$$第三章 \ \ 解决问题$$</h2><p>$$上一章，我们学习了解决问题的方法，现在是时候解决一些问题了！$$</p>
<h3 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h3><p>背包DP非常经典，每个OIer都应该掌握，我们现在从最基础的学起</p>
<h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">01背包问题</a></h4><p>题目相当于要你选若干个物品，让他们的体积不超过背包容量，且价值最大。<br><strong>是时候用上三部曲了！</strong></p>
<ol>
<li>状态表示——集合：$f[i][j]$ 表示考虑前 $i$ 个物品，且总体积不超过 $j$ 的集合下能获得的最大价值。</li>
<li>状态表示——属性：因为是求最大价值，故为 $max$。</li>
<li>状态计算——集合划分：考虑第 $i$ 个选不选。<ul>
<li>不选或选不了（剩余体积不够 $j &lt; v[i]$）：$f[i - 1][j]$。</li>
<li>选：$f[i - 1][j - v[i]] + w[i]$。</li>
</ul>
</li>
</ol>
<p>那么代码里就这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = f[i - 1][j]; //不选，这种情况绝对可以选择</span><br><span class="line">if (j &gt;= v[i]) //体积必须足够，否则不能放置</span><br><span class="line">    f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); //选，花费v[i]的体积，获得w[i]的价值</span><br></pre></td></tr></table></figure>
<h4 id="完整代码，时间复杂度：-O-nm"><a href="#完整代码，时间复杂度：-O-nm" class="headerlink" title="完整代码，时间复杂度：$O(nm)$"></a>完整代码，时间复杂度：$O(nm)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) </span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ ) &#123;</span><br><span class="line">            f[i][j] = f[i - 1][j];</span><br><span class="line">            if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我想啊想，那第一维只考虑到 $i - 1$ 能不能优化呢？</p>
<h3 id="能！"><a href="#能！" class="headerlink" title="能！"></a>能！</h3><p>我们用滚动数组优化，<code>f[1][j]放到f[1][j]，f[2][j]放到f[0][j]，f[3][j] 可以覆盖f[1][j]，也就是放到f[i &amp; 1][j]上...</code>这里可以直接把每个用到 $f$ 的位置 <code>&amp;1</code> 就可以了。<code>&amp;1</code>就相当于<code>%2</code>。</p>
<h4 id="另：之后的问题我就不写滚动数组了，滚动数组只是能优化空间，不在空间不足的情况下无需使用。"><a href="#另：之后的问题我就不写滚动数组了，滚动数组只是能优化空间，不在空间不足的情况下无需使用。" class="headerlink" title="另：之后的问题我就不写滚动数组了，滚动数组只是能优化空间，不在空间不足的情况下无需使用。"></a>另：之后的问题我就不写滚动数组了，滚动数组只是能优化空间，不在空间不足的情况下无需使用。</h4><p>滚动数组也就相当于反复覆盖之前无用的空间而已</p>
<h4 id="也就相当于："><a href="#也就相当于：" class="headerlink" title="也就相当于："></a>也就相当于：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = f[i &amp; 1][j]</span><br></pre></td></tr></table></figure>
<h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f[1][j] = f[1][j]</span><br><span class="line">f[2][j] = f[0][j]</span><br><span class="line">f[3][j] = f[1][j]</span><br><span class="line">f[4][j] = f[0][j]</span><br></pre></td></tr></table></figure>
<p>然而并不会影响结果，因为每次覆盖的都是没有用的。</p>
<h4 id="完整代码，时间复杂度：-O-nm-1"><a href="#完整代码，时间复杂度：-O-nm-1" class="headerlink" title="完整代码，时间复杂度：$O(nm)$"></a>完整代码，时间复杂度：$O(nm)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[2][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) </span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ ) &#123;</span><br><span class="line">            f[i &amp; 1][j] = f[i - 1 &amp; 1][j];</span><br><span class="line">            if (j &gt;= v[i]) f[i &amp; 1][j] = max(f[i &amp; 1][j], f[i - 1 &amp; 1][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n &amp; 1][m];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我要得寸进尺，能不能把第一维直接省去呢？</p>
<h3 id="能！！！"><a href="#能！！！" class="headerlink" title="能！！！"></a>能！！！</h3><p>但不能像之前直接更改了，因为更新 $f[j]$ 的已经被更新过，不能再次更新，需要将体积倒着枚举，这样的话：<br><code>f[j]</code>没有被更新过，而且<code>f[j - v[i]]</code>由于<code>j - v[i]</code>比<code>j</code>小，没有被遍历过，也就是 <code>i - 1</code>更新的东西，这样就可以了。</p>
<h4 id="完整代码，时间复杂度：-O-nm-2"><a href="#完整代码，时间复杂度：-O-nm-2" class="headerlink" title="完整代码，时间复杂度：$O(nm)$"></a>完整代码，时间复杂度：$O(nm)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) </span><br><span class="line">        for (int j = m; j &gt;= v[i]; j -- ) &#123; //体积小于v[i]的f不会被更新，所以只需遍历到v[i]</span><br><span class="line">            f[j] = max(f[j], f[j - v[i]] + w[i]); //现在的f[j]就是f[i - 1][j]，并且可以选择i</span><br><span class="line">            //而f[j - v[i]]没有被更新，所以就又变成了f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解完01背包，我们再来看一看完全背包。<br><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3/">完全背包问题</a><br>完全背包跟01背包好像并没什么不同，只是一个物品可以放多个而已。<br>那我们就直接枚举当前物品用多少个就行了。</p>
<h4 id="完整代码，时间复杂度：-O-nm-2"><a href="#完整代码，时间复杂度：-O-nm-2" class="headerlink" title="完整代码，时间复杂度：$O(nm^2)$"></a>完整代码，时间复杂度：$O(nm^2)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1100;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ ) &#123;</span><br><span class="line">            f[i][j] = f[i - 1][j];</span><br><span class="line">            for (int k = 1; k &lt;= j / v[i]; k ++ ) &#123;</span><br><span class="line">                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样会 $\color{blue}{TLE}$，所以我们要考虑优化，那我们在选一个物品后，能不能继续考虑前i个物品呢？<br>那么我们可以看一个图了解一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i, j] = max(f[i - 1, j], f[i - 1, j - v] + w,  f[i - 1, j - 2 * v] + 2 * w, f[i - 1, j - 3 * v] + 3 * w, ...)</span><br><span class="line">f[i, j - v] = max(         f[i - 1, j - v]    ,  f[i - 1, j - 2 * v] + w    , f[i - 1, j - 3 * v] + 2 * w...)</span><br></pre></td></tr></table></figure>
<p>我们惊奇的发现，除了 $f[i][j]$ 第一项的不选之外，每一项都与下面差一个 $w$ ，那么除了第一项以外的决策的最大值与 $f[i][j - v]$ 的值只相差一个 $w$ ，只需在 $f[i][j - v]$ 的基础上加一个 $w$ 即可，那么我们就可以把状态转移方程变成这样：<br><code>f[i][j] = max(f[i][j], f[i][j - v] + w);</code><br>这样就可以通过了。</p>
<h4 id="完整代码，时间复杂度：-O-nm-3"><a href="#完整代码，时间复杂度：-O-nm-3" class="headerlink" title="完整代码，时间复杂度：$O(nm)$"></a>完整代码，时间复杂度：$O(nm)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1100;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ ) &#123;</span><br><span class="line">            f[i][j] = f[i - 1][j];</span><br><span class="line">            if (j &gt;= v[i]) </span><br><span class="line">                f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以用类似01背包的方式来省去第一维，注意这回背包大小不是倒着枚举，因为这回我们转移到当前状态的应该是已经被第 $i$ 个物品更新过的，与01背包不同，所以需要正着枚举。</p>
<h4 id="完整代码，时间复杂度：-O-nm-4"><a href="#完整代码，时间复杂度：-O-nm-4" class="headerlink" title="完整代码，时间复杂度：$O(nm)$"></a>完整代码，时间复杂度：$O(nm)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1100;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        for (int j = v[i]; j &lt;= m; j ++ ) &#123;</span><br><span class="line">            f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4/">多重背包问题1</a> <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5/">多重背包问题2</a> <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/6/">多重背包问题3</a><br>多重背包问题只不过是在完全背包的基础上有了一个数量的限制，所以我们只需要在加一层循环枚举个数就行了。</p>
<h4 id="完整代码，时间复杂度：-O-nms"><a href="#完整代码，时间复杂度：-O-nms" class="headerlink" title="完整代码，时间复杂度：$O(nms)$"></a>完整代码，时间复杂度：$O(nms)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N], s[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ ) &#123;</span><br><span class="line">            f[i][j] = f[i - 1][j];</span><br><span class="line">            for (int k = 1; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k ++ ) //枚举选的个数，但要判断能不能装下。</span><br><span class="line">                f[i][j] = max(f[i][j] , f[i - 1][j - k * v[i]] + k * w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那你就会问了，同样的题你贴三遍干啥？那现在我们进入<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5/">多重背包问题2</a>！！！<br>这道题与上一道题相同，但增大了数据范围，意味着刚才的暴力将会 $\color{green}{TLE}$<br>那我们能不能用想刚才完全背包一样优化呢？我们来试一试，就会发现是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, ....., f[i - 1][j - sv] + sw);</span><br><span class="line">f[i][j - v] = max(       , f[i - 1][j - v]    , f[i - 1][j - 2v] + w , ....., f[i - 1][j - sv] + (s - 1)w, f[i - 1][j - (s + 1)v] + sw);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这后面这一坨啊，和我们下面这些非常相似的对吧，但是呢，比较 $\color{red}{蛋疼}$ 的是f[i][j - v]多了一项对吧     -yxc</p>
</blockquote>
<p>那我们能不能求出前面的最大值呢？不行。问题就像这样：给你所有数的最大值以及最后一个数，你能不能求出前面几项的大值呢？如果你做到了，请立即私信我！！！<br>所以我们<strong>不能</strong>用这种方式直接优化。</p>
<p>但我们可以用二进制优化方式！！！！！<br>假设我们想去凑出来 $s$ 的话，假设我们有 $1023$ 个数，我们真的需要从 $0$ 枚举到 $1023$ 吗？<br>我们可以把若干个第 $i$ 个物品打包到一块考虑。例如说我们打包 $10$ 组，分别有 <code>1,2,4,8,16...,512</code> 个物品，然后每组最多只能选一次。</p>
<p>又有人要问了，这样一定能凑出从 $0$ 到 $1023$ 中的所有数吗？可以，因为这不就是一位一位的二进制表示吗，用二进制表示可以表示从 $0$ 到 $1023$ 的所有数！当然也可以这样想：<br>首先我使用 $1$ ，可以凑出 $0-1$ 的所有数，接下来我把 $0-1$ 的所有数都加上 $2$ ，就可以凑出 $0-3$ ……，这样就可以一直凑到 $1023$。</p>
<p>然后 <code>1,2,4,8,16...,512</code> 每一组都可以看成是一个01背包里的物品，也就是我们用了 $10$ 个新的物品来代替我们第 $i$ 个物品，就可以只用 $10$ 次枚举出 $1024$ 种了。如此下来，每一种物品都变成了 $10$ （其实是 $logs$） 个物品，每个物品只能选一个，这样问题就变成了一个01背包问题。</p>
<h4 id="完整代码，时间复杂度：-O-nmlogs"><a href="#完整代码，时间复杂度：-O-nmlogs" class="headerlink" title="完整代码，时间复杂度：$O(nmlogs)$"></a>完整代码，时间复杂度：$O(nmlogs)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 12010, M = 2010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[M];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        int k = 1;</span><br><span class="line">        while (k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a * k; //把一个物品拆分成logs个物品。</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a * s; //由于是一个一个往上拆，最后有可能剩下一些物品，也同样要加进去。</span><br><span class="line">            //除非你倒着拆，直接把它拆成2进制数，同样也是可以的。</span><br><span class="line">            //在这里，例如8，先拆掉一个1，再拆一个2，再拆一个4，最后剩下一个1。</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">        for (int j = m; j &gt;= v[i]; j -- )</span><br><span class="line">            f[j] = max(f[j], f[j - v[i]] + w[i]);  //最后再这些物品中进行01背包</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会说：这已经很难了，难道还有比这个更难的？有！让我们一起看<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/6/">多重背包问题3</a><br>首先我们还是得从公式入手。<br><img src="https://s3.bmp.ovh/imgs/2022/01/37f49a0f8e5302ac.png"><br>你会发现，能转移到 $f[i][j]$ 无非就从 $f[i - 1][j - v]$ 到 $f[i - 1][j - sv]$，那你在来看看这幅图。$r$ 就是 $j % v$ 的余数，像此图中，$r +5v$ 就可以从 $r -&gt; r + 4v$ 之间的最大值转移过来。<br><img src="https://s3.bmp.ovh/imgs/2022/01/22085a9d1b1bebe1.png"><br>这就像一个滑动窗口,那么我们就可以用滑动窗口解决此问题。</p>
<h4 id="其实你由此会发现一个性质：完全背包就是前缀最大值，多重背包就是滑动窗口。"><a href="#其实你由此会发现一个性质：完全背包就是前缀最大值，多重背包就是滑动窗口。" class="headerlink" title="其实你由此会发现一个性质：完全背包就是前缀最大值，多重背包就是滑动窗口。"></a>其实你由此会发现一个性质：完全背包就是前缀最大值，多重背包就是滑动窗口。</h4><h4 id="完整代码，时间复杂度：-O-nm-5"><a href="#完整代码，时间复杂度：-O-nm-5" class="headerlink" title="完整代码，时间复杂度：$O(nm)$"></a>完整代码，时间复杂度：$O(nm)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 20010;</span><br><span class="line">int n, m;</span><br><span class="line">int f[N], g[N], q[N];</span><br><span class="line">//拷贝数组，因为这里不能使用一维优化，因为如果倒叙枚举，你就不能用滑动窗口了。</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        int v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        memcpy(g, f, sizeof f);</span><br><span class="line">        for (int j = 0; j &lt; v; j ++ ) &#123;</span><br><span class="line">            int hh = 0, tt = -1;</span><br><span class="line">            for (int k = j; k &lt;= m; k += v) &#123;</span><br><span class="line">                if (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ; //剔除超出长度元素</span><br><span class="line">                if (hh &lt;= tt) f[k] = max(f[k], g[q[hh]] + (k - q[hh]) / v * w); //更新当前答案</span><br><span class="line">                while (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ;</span><br><span class="line">                //维持单调性</span><br><span class="line">                //这里也可以这样写，更易理解</span><br><span class="line">                //while (hh &lt;= tt &amp;&amp; g[q[tt]] &lt;= g[k] - (k - q[tt]) / v * w) tt -- ;</span><br><span class="line">                q[ ++ tt] = k;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来了解<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/9/">分组背包问题</a>，这是基础课最后一道背包题了，之前只讲过一道提高课背包问题——多重背包问题3，讲完这道题我们开始讲提高课题目。<br>相当于在问你每组物品里最多选一个，问最大价值。<br>首先我们在最外边枚举每一组，里面的 $f[j]$ 表示总体积为 $j$ 能获得的最大价值。<br>但里边有一些不同点，这里必须先枚举体积，再枚举每一个物品。因为如果先枚举物品，那么你下一个物品不管从哪里转移都已经被上一个更新，同时，体积必须倒着枚举，否则一个物品将会被重复选择。</p>
<h4 id="完整代码，时间复杂度：-O-nms-1"><a href="#完整代码，时间复杂度：-O-nms-1" class="headerlink" title="完整代码，时间复杂度：$O(nms)$"></a>完整代码，时间复杂度：$O(nms)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        int a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        for (int j = 1; j &lt;= a; j ++ ) &#123;</span><br><span class="line">            cin &gt;&gt; v[j] &gt;&gt; w[j];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = m; j &gt;= 0; j -- ) &#123; //先枚举体积，倒着枚举这样就不会被自己更新</span><br><span class="line">            for (int k = 1; k &lt;= a; k ++ ) &#123; //在枚举每一个</span><br><span class="line">                if (j &gt;= v[k]) //这里与其他01背包有些不同，因为在枚举j的时候还没有枚举每一个数，故需特判</span><br><span class="line">                    f[j] = max(f[j], f[j - v[k]] + w[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，休息片刻，我来讲提高课背包问题。<br>2000years later…..<br>好，现在我们来看第一道题——<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/425/">采药</a><br>这道题的题目大意就是给你一些物品然后给你一些时间，每个物品想要拿到需要时间，并会获得一定的价值，问最大价值<br>这不就是我们众所周知的01背包问题吗，只要把 <strong>时间</strong> 转换成 <strong>背包大小</strong>，搞到一个物品的 <strong>时间</strong> 变为 <strong>体积</strong> 就可以了。其他像一维优化的我就不讲了，01背包那里都讲过了。</p>
<h4 id="完整代码，时间复杂度：-O-nm-6"><a href="#完整代码，时间复杂度：-O-nm-6" class="headerlink" title="完整代码，时间复杂度：$O(nm)$"></a>完整代码，时间复杂度：$O(nm)$</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int f[N][N * 10];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ ) &#123;</span><br><span class="line">            f[i][j] = f[i - 1][j];</span><br><span class="line">            if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/11/goodproblems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Winter/Hugo">
      <meta itemprop="description" content="编程语言C++，主要混迹于ACWing...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hugo的个人小站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/11/goodproblems/" class="post-title-link" itemprop="url">goodproblems</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-11 09:29:34" itemprop="dateCreated datePublished" datetime="2021-12-11T09:29:34+08:00">2021-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-31 12:20:26" itemprop="dateModified" datetime="2022-01-31T12:20:26+08:00">2022-01-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones/">统计全一子矩形</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.acwing.com/video/1453/">讲解</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/">和为目标值且不重叠的非空子数组的最大数目</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution/c-qian-zhui-he-tan-xin-shuang-bai-by-scyq/">讲解1</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution/jiang-jiang-wei-shi-yao-ke-yi-shi-yong-t-agjh/">讲解2</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/">https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/18211/">https://www.acwing.com/solution/content/18211/</a>    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/04/2021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Winter/Hugo">
      <meta itemprop="description" content="编程语言C++，主要混迹于ACWing...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hugo的个人小站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/04/2021/" class="post-title-link" itemprop="url">2021 csp-j 游记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-04 19:45:07" itemprop="dateCreated datePublished" datetime="2021-12-04T19:45:07+08:00">2021-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-11 09:28:53" itemprop="dateModified" datetime="2021-12-11T09:28:53+08:00">2021-12-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="考试当天"><a href="#考试当天" class="headerlink" title="考试当天"></a>考试当天</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><p>开场先做此题，发现暴力无法得全部分数，有开始思考求模数，大概30分钟后开始了对拍</p>
<h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><p>看这题，一开始只想到了75分做法，后来我想：我总不能连第二题都不可以AC吧，然后全力冲击第二题，想出了100分做法后开写，对拍没排成，似乎一直<code>Segmentation Fault </code>但大样例过了，我就把它放过去了</p>
<h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><p>后来一直冲击此题，考试最后突然爆出一堆奇奇怪怪的错误，搞得我没调对</p>
<h4 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h4><p>暴力30分走人</p>
<h4 id="出去后"><a href="#出去后" class="headerlink" title="出去后"></a>出去后</h4><p>最后出考场预计[100 + 100 + rp + 30] = 230+</p>
<h3 id="第二天自测"><a href="#第二天自测" class="headerlink" title="第二天自测"></a>第二天自测</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/04/2021/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/24/acwing-yyds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Winter/Hugo">
      <meta itemprop="description" content="编程语言C++，主要混迹于ACWing...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hugo的个人小站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/24/acwing-yyds/" class="post-title-link" itemprop="url">acwing yyds</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-24 21:31:38" itemprop="dateCreated datePublished" datetime="2021-10-24T21:31:38+08:00">2021-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 17:47:46" itemprop="dateModified" datetime="2021-11-09T17:47:46+08:00">2021-11-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>我在此向大家隆重推荐一个学习算法的好网站，那就是：<a target="_blank" rel="noopener" href="http://www.acwing.com!/">www.acwing.com！</a></li>
<li><a target="_blank" rel="noopener" href="http://www.acwing.com/">www.acwing.com</a> yyds!!!!</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Winter/Hugo</p>
  <div class="site-description" itemprop="description">编程语言C++，主要混迹于ACWing...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Winter/Hugo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
